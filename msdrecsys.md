# ML System Design Doc - RecSys project for marketplace [RU]
## Дизайн ML системы - Рекомендательная система для маркетплейса
*Шаблон ML System Design Doc от телеграм-канала [Reliable ML](https://t.me/reliable_ml)*   

- Рекомендации по процессу заполнения документа (workflow) - [здесь](https://github.com/IrinaGoloshchapova/ml_system_design_doc_ru/blob/main/ML_System_Design_Doc_Workflow.md).  
- Детальный доклад о том, что такое ML System Design Doc и о том, как, когда и зачем его составлять - [тут](https://www.youtube.com/watch?v=PW9TGNr1Vqk).
    
### 1. Цели и предпосылки 
#### 1.1. Зачем идем в разработку продукта?  

- Бизнес-цель: Увеличение продаж через сайт с помощью создания персональных рекоммендаций для каждого юзера.
- Почему станет лучше, чем сейчас, от использования ML: ML поможет создать персонализированную подборку товаров для юзера, которая основана на его предпочтениях, что лучше показа "Самые популярные товары", которые в большинстве своем могут быть и не нужны юзеру. Персонализация - ключик к сердцу клиента.
- Что будем считать успехом итерации с точки зрения бизнеса: Увеличение продаж товаров из предложенной выборки товаров и целевая метрика качества разработанной ML-модели не ниже 85%.

#### 1.2. Бизнес-требования и ограничения  

- Краткое описание БТ и ссылки на детальные документы с бизнес-требованиями: Система должна обеспечивать выдачу рекомендаций в режиме реального времени с задержкой не более 5 секунд. Продукты должны быть рекомендованы с учетом их актуальности и интересов клиента.
- Бизнес-ограничения: Система должна работать в рамках существующей инфраструктуры маркетплейса и не должна вызывать негативное воздействие на общее функционирование платформы. Прогнозы не должны содержать информацию, которая могла бы нарушить конфиденциальность клиентов.
- Что мы ожидаем от конкретной итерации: На текущей итерации мы планируем реализовать базовую модель классификации товаров, которая будет отмечать товары как подходящие или неподходящие. Модель будет оцениваться по уровню качества и устойчивости.
- Описание бизнес-процесса пилота, насколько это возможно - как именно мы будем использовать модель в существующем бизнес-процессе?: В рамках пилотного запуска мы планируем интегрировать рекомендательную систему в страницы продуктов нашего маркетплейса поднятого самостоятельно. После того как клиент посетит страницу товара, система будет предлагать ему список рекомендованных товаров на основе его предпочтений и истории. 
- Что считаем успешным пилотом? Критерии успеха и возможные пути развития проекта: 
    - Критерий успеха: Процент клиентов, следовавших рекомендациям системы, увеличится на 15% по сравнению с предыдущим периодом.
    - Пути развития: разработать алгоритм, который будет стоек к холодному старту.

#### 1.3. Что входит в скоуп проекта, что не входит   

- На закрытие каких БТ подписываемся в данной итерации: 
    - В рамках данной итерации фокус будет на проверке правильности интерпретации признаков моделью. 
    - Также мы определим целевые метрики и методы мониторинга качества модели. 
    - Будет проведен верный предпроцессинг для категориальных признаков. 
    - В данной итерации мы подписываемся на то, что будет работать модель, которая выдает топ товаров.
- Что не будет закрыто: 
    - Измерение продуктовых метрик, таких как конверсия, CTR, продажи, ибо мы не имеем достаточного количество уникальных юзеров для их измерения.
    - На данной итерации мы не будем заниматься измерением требования успеха проекта, такого как повышение конверсии. Это остается на будущие этапы развития.
    - Настройка фронтенда также не будет включена в текущий скоуп.
- Описание результата с точки зрения качества кода и воспроизводимости решения: Код написан в Jupyter notebook, где проведен EDA, обучена ML-модель на имеющемся датасете, подобраны оптимальные гиперпараметры обучаемой модели.
- Описание планируемого технического долга (что оставляем для дальнейшей продуктивизации): 
    - Кастомизация пайплайна обработки данных для адаптации под конкретные входные данные.
    - Определение ограничений и требований к системе для дальнейшего масштабирования.
    - Определение стэка технологий, который будет использован для проекта на следующих этапах разработки.
#### 1.4. Предпосылки решения  

- Описание всех общих предпосылок решения, используемых в системе – с обоснованием от запроса бизнеса: какие блоки данных используем, горизонт прогноза, гранулярность модели, и др.:  
Использование данных о покупках и предпочтениях клиентов: Мы будем анализировать данные о совершенных покупках с учетом гранулярности клиент-товар-состояние сделки. Подсказки для рекомендаций будут строиться на основе истории покупок клиентов.

- Признаки из сделок: Мы будем использовать информацию, содержащуюся в данных сделок. Это включает в себя детали о продуктах, ценах, истории сделок и другие связанные атрибуты. Эти признаки будут использоваться для построения контекста для рекомендаций.

- Горизонт прогноза: Горизонтом прогноза будет считаться текущая сделка. Мы будем строить рекомендации на основе данных, доступных на момент принятия решения о покупке, чтобы предложить клиенту наилучшие варианты.

- Привязка к бизнес-целям: Рекомендации будут выстраиваться с учетом бизнес-целей маркетплейса, таких как увеличение конверсии, среднего чека, удержание клиентов и другие.

- Стремление к персонализации: Мы стремимся к созданию персонализированных рекомендаций, учитывая уникальные интересы и поведение каждого клиента. Решение будет опираться на индивидуальные данные и историю покупок.

- Безопасность и конфиденциальность: Мы обязуемся обеспечить безопасное хранение и обработку данных клиентов. Рекомендации будут создаваться на основе анонимных агрегированных данных, чтобы обеспечить конфиденциальность клиентов.

### 2. Методология
#### 2.1. Постановка задачи  

- Что делаем с технической точки зрения: рекомендательная система

#### 2.2. Блок-схема решения  

- Блок-схема для бейзлайна и основного MVP с ключевыми этапами решения задачи: [Блок-схема](https://github.com/limaKKG/Recsys/blob/main/1_photo.jpg) для пилота с ключевыми этапами решения задачи.

#### 2.3. Этапы решения задачи

- Этап 1 - Подготовка бейзлайна

Шаг 1. Сбор данных, отбор признаков, анализ. Загружаем их в тетрадь юпитера из предоставленного датасета ab_test.csv. Проверяем данные на пропуски. 

Целевая переменная
| Название данных  | Есть ли данные в компании (если да, название источника/витрин) | Требуемый ресурс для получения данных (какие роли нужны) | Проверено ли качество данных (да, нет) |
| ------------- | ------------- | ------------- | ------------- |
|Данные о товаре в БД | ab_test.csv -> ecom.nm  | DS | - |

Признаки:
| Название данных  | Есть ли данные в компании (если да, название источника/витрин) | Требуемый ресурс для получения данных (какие роли нужны) | Проверено ли качество данных (да, нет) |
| ------------- | ------------- | ------------- | ------------- |
|Данные о платформе покупки | ab_test.csv -> platform  | DS | - | 
|Данные о времени покупки | ab_test.csv -> utc_event_time  | DS | - | 
|Данные о дате покупки | ab_test.csv -> utc_event_date  | DS | - | 
|Данные об id пользователя | ab_test.csv -> user_id  | DS | - | 
|Данные о пока не знаю | ab_test.csv -> event_type  | DS | - | 
|Данные о цене товара умноженного на 100 | ab_test.csv -> ecom.price100  | DS | - | 
|Данные о количестве купленного товара | ab_test.csv -> ecom.qty	  | DS | - | 

MVP: тетрать юпитера с загруженными признаками.

Шаг 2. Обработка данных и подготовка их к дальнейшему обучению.
- Поиск пропусков в данных
- Качественные данные: Применение Label Encoding | One-Hot Encoding | Hashing trick для категориальных данных, чтобы в последствии можно было обучать модель
- Создаем отложенную выборку. Делим данные  на 70/30

MVP: Данные готовые для обучения модели

Шаг 3. Поиск и обучение модели с необходимым для бейзлайна уровнем метрик.

- Определение целевой и дополнительных метрик для оценки качества рекомендательной системы.
- Подбор модели машинного обучения, чтобы целевая метрика была самой высокой из выбранных и опробованных моделей. Возможны ансамбли.
- Подбор гиперпараметров на кросс-валидации

MVP: тетрадь юпитера с определённой лучшей моделью и её параметрами, отвечающая заявленными критериям качества

Шаг 4. Анализ результатов. Проверка значимости признаков.

- Интерпретации результата: Проверка на адекватность. Модель должна выдавать адекватные результаты, то есть если юзер купил Iphone 14, но остальные покупки не были дорогостоящими(даже если это первая покупка, то вряд-ли юзер будет постоянно  покупать дорогостоящие вещи) модель не должна выдавать смартоны соотвествующей ценовой категории.
- Проверка на отсуствие переобучения модели с помощью валидационных кривых

MVP: обученная модель соблюдает бизнес-логику и ведет себя адекватно.

Шаг 5. - Развертывание модели согласно бизнес требованиям заказчика. Готовим стэк согласно требованиям заказчика, переносим туда наш бейзлайн и добиваемся того, чтобы модель могла исполняться согласно заявленной логике. Настраиваем интеграцию с тестовой базой, разворачиваем интерфейс, настраиваем пайплайны.

MVP: модель работает с тестовой средой с заявленным качеством согласно бизнес-требованиям.

Шаг 6. - Считаем системные требования к модели. Проводим расчёт вычислительной мощности необходимой для работы системы.

MVP: составлены системные требования для модели

Этап 2. Создание пилота.

Шаг 7. - Утверждение метрик пилота. Определяем финальные метрики, прокси-метрики и технические метрики, при достижении которых модель будет запущена в деплой.

MVP: определены целевые метрики на основании имеющихся данных и согласованные с бизнесом

Шаг 8. - Подготовка модели к деплою. Проводим обогощение модели данными, улучшаем предобработку и подбор параметров модели до тех пор, пока не удастся достичь заявленные цели.

MVP: модель, удовлетворяющая заявленным метрикам

Шаг 9. - Деплой. Выкатываем модель в рабочую среду и проводим тестирование на достижение метрик и отказоустойчивости согласно требованиям.
### 3.  Создание пилота.

#### 3.1. Способ оценки пилота  
  
- Выбор тестовой группы клиентов: Мы случайным образом выберем 10 клиентов из активных пользователей нашего маркетплейса для участия в пилоте. Эти клиенты будут представлять разнообразные интересы и покупательские предпочтения.

- Подготовка данных: Для каждого выбранного клиента мы подготовим данные о его предыдущих покупках, просмотрах товаров и интеракциях с платформой. Эти данные будут использоваться для тестирования рекомендаций.

- Проведение пилота: Каждому из выбранных клиентов будет предоставлен список рекомендованных товаров, созданный нашей рекомендательной системой. Мы будем отслеживать, какие товары клиент выбирает для покупки или добавляет в корзину.

- Оценка качества рекомендаций: Для оценки эффективности пилота мы будем анализировать следующие метрики:

- Процент потерянных предложений: Доля товаров, которые были потеряны системой и не были предложены клиенту, но могли бы быть им интересны.
- Сравнение с рекомендациями экспертов: Мы предоставим рекомендации для оценки экспертам, которые занимаются подбором товаров вручную. Сравним, какое количество из рекомендаций системы были бы также предложены экспертами и насколько это соотносится с решением системы.
- Анализ результатов: По окончании пилота мы проведем анализ полученных данных и сравним эффективность рекомендаций системы с анализом экспертов. Эти результаты будут использованы для дальнейшей оптимизации модели и алгоритмов.
#### 3.2. Что считаем успешным пилотом  
  
- Процент потерянных предложений (FN): Эта метрика измеряет, какую долю товаров, которые могли бы заинтересовать клиента, система не предложила ему. Успешным считается пилот, если процент потерянных предложений составит не более 20% от общего числа вариантов.
- Точность рекомендаций: Метрика измеряет, насколько предложенные системой товары действительно соответствуют интересам клиента. Успешным считается пилот, если точность рекомендаций будет на уровне не менее 70%.

### 4. Внедрение   

#### 4.1. Архитектура решения   
  
- Блок схема и пояснения:  Будет добавлено позже, после выполнения следующего этапа и описания основных элементов по нотации C4
  
#### 4.2. Описание инфраструктуры и масштабируемости 
  
- Какая инфраструктура выбрана и почему:
Для развертывания рекомендательной системы нашего маркетплейса мы выбрали следующую инфраструктуру:
    - Контейнеризация с Docker: Мы используем Docker для контейнеризации нашего Flask-приложения и сервиса машинного обучения. Это позволяет нам обеспечить изоляцию приложений и удобное развертывание.
    -Apache Airflow: Для автоматизации и планирования задач, таких как обновление моделей и подготовка данных, мы используем Apache Airflow. Это обеспечивает более эффективное управление рабочими процессами.
- Плюсы и минусы выбора:
    - Плюсы: 
        - Изоляция и масштабируемость: Контейнеризация с Docker позволяет нам изолировать приложения и легко масштабировать ресурсы в зависимости от нагрузки.
        - Гибкость развертывания: Docker обеспечивает единообразное развертывание приложений в разных средах, упрощая процесс разработки и тестирования.
        - Планирование и автоматизация: Apache Airflow предоставляет возможность автоматизировать задачи и планировать выполнение процессов, что способствует эффективной организации рабочего процесса.
    - Минусы:
        - Настройка: Настройка и конфигурирование Docker и Apache Airflow может потребовать времени и знаний, которые я не имею.
- Почему финальный выбор лучше других альтернатив: Финальный выбор данной инфраструктуры лучше других альтернатив по следующим причинам:
    - Гибкость и масштабируемость: Использование Docker позволяет нам легко масштабировать приложения и обеспечивает гибкость в развертывании.
    - Управление задачами: Apache Airflow предоставляет мощные инструменты для управления задачами и автоматизации процессов.
    - Интеграция: Выбранная инфраструктура хорошо интегрируется с другими инструментами и технологиями, которые мы используем, такими как Flask и API.  
#### 4.5. Integration points  
  
- Описание взаимодействия между сервисами (методы API и др.) 
    - Web-приложение (Flask):
        - Принимает HTTP-запросы от пользователей маркетплейса.
        - Использует методы API для передачи данных сервису машинного обучения.
        - Возвращает рекомендации в формате JSON клиентам.
    - Сервис машинного обучения (ML сервис):
        - Принимает API-запросы от веб-приложения.
        - Использует обученные модели для генерации рекомендаций на основе входных данных.
        - Возвращает рекомендации в формате JSON в веб-приложение.
    - Apache Airflow:
        - Запускает задачи по обновлению моделей и подготовке данных согласно заданному расписанию.
        - Взаимодействует с веб-приложением и сервисом машинного обучения через API для обновления данных и моделей.






